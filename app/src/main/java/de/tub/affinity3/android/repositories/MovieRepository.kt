package de.tub.affinity3.android.repositories

import android.content.Context
import de.tub.affinity3.android.api.ApiMoviesClient
import de.tub.affinity3.android.classes.Search
import de.tub.affinity3.android.classes.data.Movie
import de.tub.affinity3.android.persistence.AffinityDatabase
import de.tub.affinity3.android.classes.data.MovieAllRatings
import io.reactivex.BackpressureStrategy
import io.reactivex.Completable
import io.reactivex.Flowable
import io.reactivex.Observable
import io.reactivex.ObservableEmitter
import io.reactivex.rxkotlin.subscribeBy
import io.reactivex.schedulers.Schedulers
import timber.log.Timber

/**
 * This repository will be used as @single truth for accessing movies.
 */
class MovieRepository(val context: Context) {

    private val movieDao = AffinityDatabase.getInstance(context).movieDao()

    private val apiService = ApiMoviesClient.imdb()

    fun findAllWithRatings(): Flowable<List<MovieAllRatings>> {
        return movieDao.findAllWithRatings()
            .subscribeOn(Schedulers.io())
    }

    /**
     * Fetches all [Movie]s that are on the watchlist
     *
     * @return [Flowable] of a [List] of [Movie] objects.
     */
    fun findAllOnWatchlist(): Flowable<List<MovieAllRatings>> {
        Timber.d("Fetching watchlist")
        return movieDao.findAllOnWatchlist()
            .subscribeOn(Schedulers.io())
    }

    /**
     * Fetches all [Movie]s by the given ids
     *
     * @param idList: List of imdb ids
     * @return [Flowable] of a [List] of [Movie] objects.
     */
    fun findAllWithIds(idList: List<String>): Flowable<List<MovieAllRatings>> {
        return movieDao.findAllByIds(idList)
            .subscribeOn(Schedulers.io())
    }

    /**
     * Fetches a movie by a given ID
     *
     * @return [Flowable] of [Movie] object.
     */
    fun findById(id: String): Flowable<Movie> {
        Timber.i("Fetching movie by imdbId $id")
        return Observable.create<Movie> { emitter ->
            if (id.toIntOrNull() != null) {
                emitter.onError(Error("Id is generated by dev function and thus does not reflect an IMDB movie ID"))
                emitter.onComplete()
            }
            val movie = movieDao.findByIdSync(id)
            if (movie == null) {
                Timber.i("Didn't find persisted movie with imdbId $id")
                Timber.i("Fetching movie with imdbId $id from Omdb API ...")

                apiService.getMovie(id)
                    .subscribeBy(
                        onNext = { apiMovie ->
                            Timber.i("Received movie with imdbId ${apiMovie.imdbId} from API")

                            val persistenceMovie = apiMovie.toPersistenceMovie()
                            addMovie(persistenceMovie).subscribe()
                            Timber.i("Persisted fetched movie with imdbId ${apiMovie.imdbId}")

                            emitter.onNext(persistenceMovie)
                            emitter.onComplete()
                        },
                        onError = {
                            Timber.e("Failed to fetch movie from API $it")
                            emitter.onComplete()
                        })
                    .dispose()
            } else {
                Timber.i("Found persisted movie with imdbId $id")
                emitter.onNext(movie)
                emitter.onComplete()
            }
        }
            .subscribeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.BUFFER)
    }

    /**
     * Adds the [movies] to the database.
     */
    fun addMovie(vararg movies: Movie): Completable {
        return Completable.create { it ->
            movies.forEach { movie ->
                Timber.i("Adding movie ${movie.title} to database..")
            }
            movieDao.insert(*movies)

            it.onComplete()
        }.subscribeOn(Schedulers.io())
    }

    /**
     * Updates all given [movies] in the database
     */
    fun updateMovies(vararg movies: Movie): Completable {
        return Completable.create {
            movieDao.update(*movies)
            it.onComplete()
        }.subscribeOn(Schedulers.io())
    }

    /**
     * Updates given [movie] in the database
     */
    fun updateMovie(movie: Movie): Completable {
        return updateMovies(movie)
            .subscribeOn(Schedulers.io())
    }

    /**
     * Search for movies by [title].
     */
    fun search(title: String): Flowable<List<Search>> {
        Timber.d("Search for movie $title in API")
        return Observable.create<List<Search>> { emitter ->
            apiService.searchMovies(title)
                .subscribe({
                    Timber.d("Received search response for $title")

                    if (it.search == null) {

                        searchOffline(title = title, emitter = emitter)
                    } else {
                        Timber.d("Found ${it.search.count()} movies.")
                        emitter.onNext(it.search)
                        emitter.onComplete()
                    }
                }, { error ->
                    Timber.e(error)
                    searchOffline(title, emitter)
                })
                .dispose()
            Timber.d("Start offline search for $title ...")
        }
            .subscribeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.BUFFER)
    }

    /**
     * Performs search by [title] in database and passes results to [emitter].
     *
     * If search result is empty, empty list will be emitted.
     */
    private fun searchOffline(title: String, emitter: ObservableEmitter<List<Search>>) {
        movieDao.searchByTitle(title)
            .subscribe({
                Timber.i("Found persisted movies $it")
                emitter.onNext(it)
                emitter.onComplete()
            }, { e ->
                Timber.e(e)
                emitter.onNext(emptyList())
                emitter.onComplete()
            }).dispose()
    }

    /**
     * Deletes all [movies] from the database.
     */
    fun deleteAll(): Completable {
        return Completable.create {
            movieDao.deleteAll()
            it.onComplete()
        }.subscribeOn(Schedulers.io())
    }
}
